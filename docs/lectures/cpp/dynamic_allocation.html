
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>More on pointers and arrays and dynamic allocation &#8212; IN1910 - Programming with Scientific Applications</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/tabs.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="C++ tips and tricks" href="cpptools.html" />
    <link rel="prev" title="Object-oriented Programming in C++" href="oop_in_cpp.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">IN1910 - Programming with Scientific Applications</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../README.html">
   IN1910 – Programming with Scientific Applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  General information
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../info/overview.html">
   Overview of lectures and exercises
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../info/curriculum.html">
   Curriculum
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../info/motivation.html">
   The motivation behind IN1910
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../info/exam.html">
   Project Work, Grading and Exam
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../info/help.html">
   Getting help or giving feedback
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Setting up your computer for IN1910
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../setup/setup.html">
   Installation instructions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../setup/cpp_compiler.html">
   Installing a C++ compiler
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lecture videos
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../videos/videos_H21.html">
   Lecture videos from H21
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../videos/videos_H20.html">
   Lecture videos from H20
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../videos/videos_H19.html">
   Lecture videos from H19
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lectures
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../python/python_intro.html">
   A quick Python refresher
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../python/python_oop.html">
   Object-oriented programming in Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../python/intro_to_oop.html">
     Introduction to Object-Oriented Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../python/classes_methods_decorators.html">
     Creating classes in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../python/more_oop.html">
     More on Object-Oriented Programming
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../git/version_control_with_git.html">
   Version Control with Git
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../testing_codestyle/testing_codestyle.html">
   Testing and Code style
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../testing_codestyle/writing_functioning_code.html">
     Writing Reliable Software
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../testing_codestyle/codestyle_and_docstrings.html">
     Code Style and Documentation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../testing_codestyle/type_annotations.html">
     Type annotations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="cpp.html">
   C++
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="intro_to_cpp.html">
     An introduction to C++
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="arrays_and_pointers.html">
     Arrays, Memory and Pointers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="oop_in_cpp.html">
     Object-oriented Programming in C++
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     More on pointers and arrays and dynamic allocation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="cpptools.html">
     C++ tips and tricks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="arraylist.html">
     Dynamic Arrays, aka, Array Lists
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="linked_lists.html">
     Linked Lists
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="algorithm_analysis.html">
     Algorithm Analysis and Big Oh Notation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="linkedlists_vs_dynamicarrays.html">
     Comparing Linked Lists and Dynamic Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="sorting.html">
     Sorting Algorithms
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../stochastic_processes/stochastic_processes.html">
   Stochastic processes
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../stochastic_processes/random_number_generators.html">
     Random Number Generators and Seeding
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../stochastic_processes/using_random_numbers.html">
     Using Random Numbers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../stochastic_processes/random_walks_and_markov_processes.html">
     Random Walks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../stochastic_processes/solving_the_1D_diffusion_equation.html">
     Solving the 1D Diffusion Equation using Finite Differences
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../stochastic_processes/markov_chains.html">
     Markov processes and Markov chains
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../optimization/optimization.html">
   Software optimization and parallelism
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../optimization/software_optimization.html">
     Software Optimization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../optimization/optimization_and_mixed_programming.html">
     Optimization and Mixed Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../optimization/parallel_programming.html">
     Parallel Programming
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../summary/course_summary.html">
   Course Summary
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  <a href="https://www.uio.no/studier/emner/matnat/ifi/IN1910/h22/index.html">Course homepage at UiO</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../../../_sources/docs/lectures/cpp/dynamic_allocation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../../_sources/docs/lectures/cpp/dynamic_allocation.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        <a class="issues-button"
            href="https://github.com/finsberg/IN1910_H22/issues/new?title=Issue%20on%20page%20%2Fdocs/lectures/cpp/dynamic_allocation.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/finsberg/IN1910_H22/gh-pages?urlpath=tree/_sources/docs/lectures/cpp/dynamic_allocation.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        <a class="jupyterhub-button" href="https://hub2.jupyterhub.uio.no/hub/user-redirect/git-pull?repo=https://github.com/finsberg/IN1910_H22&urlpath=tree/IN1910_H22/_sources/docs/lectures/cpp/dynamic_allocation.md&branch=gh-pages"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="../../../_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#som-repetition">
   Som repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointers-to-objects">
   Pointers to objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#arrays-and-pointers">
   Arrays and Pointers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dynamic-memory-allocation">
   Dynamic Memory Allocation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lifetime-of-variables">
     Lifetime of Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scope-and-lifetime">
     Scope and lifetime
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deallocating-memory-and-garbage-collection">
   Deallocating Memory and Garbage Collection
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-leaks">
     Memory Leaks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-leaks-in-practice">
     Memory leaks in Practice
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#freeing-memory">
     Freeing memory
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rule-of-thumb">
     Rule of Thumb
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-destructor">
   The Destructor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stack-vs-heap">
   Stack vs Heap
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>More on pointers and arrays and dynamic allocation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#som-repetition">
   Som repetition
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pointers-to-objects">
   Pointers to objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#arrays-and-pointers">
   Arrays and Pointers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dynamic-memory-allocation">
   Dynamic Memory Allocation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lifetime-of-variables">
     Lifetime of Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scope-and-lifetime">
     Scope and lifetime
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deallocating-memory-and-garbage-collection">
   Deallocating Memory and Garbage Collection
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-leaks">
     Memory Leaks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-leaks-in-practice">
     Memory leaks in Practice
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#freeing-memory">
     Freeing memory
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rule-of-thumb">
     Rule of Thumb
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-destructor">
   The Destructor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stack-vs-heap">
   Stack vs Heap
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="more-on-pointers-and-arrays-and-dynamic-allocation">
<h1>More on pointers and arrays and dynamic allocation<a class="headerlink" href="#more-on-pointers-and-arrays-and-dynamic-allocation" title="Permalink to this headline">¶</a></h1>
<p>In this lecture we will continue looking a bit more at pointers and how they relate to arrays. We will also use what we have learned about object oriented programming to design a few classes for making list objects.</p>
<div class="section" id="som-repetition">
<h2>Som repetition<a class="headerlink" href="#som-repetition" title="Permalink to this headline">¶</a></h2>
<p>Recall that we can create <em>pointer</em> variables, that store the memory address of some data. We can for example create an <em>integer pointer</em> as follows:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// integer variable</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// integer pointer</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">b</span></code> will be a pointer, because we use the asterisk (*) when declaring it’s type. To make <code class="docutils literal notranslate"><span class="pre">b</span></code> point at <code class="docutils literal notranslate"><span class="pre">a</span></code>, meaning the variable is storing the memory address of <code class="docutils literal notranslate"><span class="pre">a</span></code>, we use the address-of operator:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// make b point at a</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">b</span></code> points at <code class="docutils literal notranslate"><span class="pre">a</span></code> and we can use it to access and change <code class="docutils literal notranslate"><span class="pre">a</span></code>, however, recall that we cannot do so directly, if we for example attempt to print it out:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>We do not get the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> (which is 12), but instead the <em>value</em> of <code class="docutils literal notranslate"><span class="pre">b</span></code>, which is the memory address, which will look something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mh">0x7ffc072c388c</span>
</pre></div>
</div>
<p>To actually get the variable a pointer is pointing to, we use the dereference operator:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>expression</p></th>
<th class="head"><p>can be read as</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int i</p></td>
<td><p>integer variable</p></td>
</tr>
<tr class="row-odd"><td><p>int *p</p></td>
<td><p>pointer variable</p></td>
</tr>
<tr class="row-even"><td><p>*x</p></td>
<td><p>pointed to by x</p></td>
</tr>
<tr class="row-odd"><td><p>&amp;x</p></td>
<td><p>address of x</p></td>
</tr>
</tbody>
</table>
<p>Also recall that we can set a pointer to point at “nothing”:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="pointers-to-objects">
<h2>Pointers to objects<a class="headerlink" href="#pointers-to-objects" title="Permalink to this headline">¶</a></h2>
<p>Let’s say we create a struct</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">GridPoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>We can then create an instance of this struct, and access its members using dot-notation:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">GridPoint</span><span class="w"> </span><span class="n">start</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">start</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>We can also make a pointer to the object:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">GridPoint</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Now, if we want to access one of the member attributes of the underlying object, we first need to dereference the pointer, and then use dot-notation:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">).</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>We need the parenthesis to get the right order of operations. This syntax works, but people thinks it looks ugly, so there is an alternative syntax that is more common to use, instead of dot syntax, we draw an arrow:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) means the member attribute of the object pointed at, and thus is equivalent to writing <code class="docutils literal notranslate"><span class="pre">(*sp).x</span></code>.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>expression</p></th>
<th class="head"><p>can be read as</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x.y</p></td>
<td><p>member y of object x</p></td>
</tr>
<tr class="row-odd"><td><p>x-&gt;y</p></td>
<td><p>member y of object pointed to by x</p></td>
</tr>
<tr class="row-even"><td><p>(*x).y</p></td>
<td><p>member y of object pointed to by x</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="arrays-and-pointers">
<h2>Arrays and Pointers<a class="headerlink" href="#arrays-and-pointers" title="Permalink to this headline">¶</a></h2>
<p>We have briefly shown how arrays can be created, for example:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">x</span></code> will be an array of 100 ints. We can access these by indexing: <code class="docutils literal notranslate"><span class="pre">x[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[1]</span></code>, <span class="math notranslate nohighlight">\(\ldots\)</span>, <code class="docutils literal notranslate"><span class="pre">x[n-1]</span></code>.</p>
<p>Earlier, we stated that an array will be <em>contiguous</em> in memory, i.e., each element follows each other directly. We can check this statement by writing out the memory addresses:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Which prints out:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="mh">0x7ffed0407920</span><span class="w"></span>
<span class="mh">0x7ffed0407924</span><span class="w"></span>
<span class="mh">0x7ffed0407928</span><span class="w"></span>
<span class="mh">0x7ffed040792c</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the memory address increases by 4 every step (it goes 8-&gt;c because it is hexadecimal), this is because memory addresses are in terms of byte (8 bits), and integers are 32-bit variables.</p>
<p>Now comes the “crazy” part, if we write out the array variable itself:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mh">0x7ffed0407920</span>
</pre></div>
</div>
<p>Not only is this a memory address, it’s the same address as the first element: <code class="docutils literal notranslate"><span class="pre">x[0]</span></code>. This fact indicates that the array variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, is almost the same as a pointer to the first variable of the array.</p>
<p>Let us highlight this in another way. Look at the following code snippet:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>Here we make an array, and then make an integer pointer and set it to point at the third element, with a value of 6. However, because array variables behave much like pointers to the first element, the reverse is also true. Now <code class="docutils literal notranslate"><span class="pre">y</span></code> will behave like an array:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This is because the square bracket indexing indicates looking at the next elements in memory, and so will behave just like an array. We could also have accessed the elements using <em>pointer arithmetic</em>:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Here, dereferencing <code class="docutils literal notranslate"><span class="pre">y</span></code> itself gives the first element, by computing <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code> we go the the next integer in memory, which would be element 2, and so on.</p>
<p>Thus, a pointer is variable that stores the memory address of some data type, but if these data lie contiguously in memory, then having the address of the first element is all we need to reference the whole set. Thus, an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code> pointer, can point to a single integer, or to a whole sequence of them. Note that the pointer itself does not know how many elements it points at, like an array does not know how many elements it contains—meaning you won’t get an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> if you go out of bounds, you get undefined behavior. Be careful!</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>expression</p></th>
<th class="head"><p>can be read as</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x[0]</p></td>
<td><p>first object pointed to by x</p></td>
</tr>
<tr class="row-odd"><td><p>x[1]</p></td>
<td><p>second object pointed to by x</p></td>
</tr>
<tr class="row-even"><td><p>x[n]</p></td>
<td><p>(n+1)th object pointed to by x</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dynamic-memory-allocation">
<h2>Dynamic Memory Allocation<a class="headerlink" href="#dynamic-memory-allocation" title="Permalink to this headline">¶</a></h2>
<p>So far we have seen how to create a pointer object, and how to make it point at something. We have also seen how to point it at “nothing” (aka null). However, we have only pointed it at things that already exist. However, it is possible to get a pointer to point at something brand new. Take a look at the following example:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>
<span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Here we first create an integer pointer. Then we say we want a new integer object to be made, and its address to point to it. An interesting consequence of this is that we have a variable that <em>is not named</em>. We can only access it through our pointer.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">new</span></code> keyword in this way is referred to as <em>dynamic memory allocation</em>.</p>
<div class="section" id="lifetime-of-variables">
<h3>Lifetime of Variables<a class="headerlink" href="#lifetime-of-variables" title="Permalink to this headline">¶</a></h3>
<p>In C++, things are automatically destroyed once they go out of scope. If you for example define a vector inside a function, then that vector simply ceases to exist once that function finished. Any dynamically allocated memory however, sticks around. Let us look at an example.</p>
<p>We have discussed how arrays are so efficient because they are contiguous in memory, but we find it annoying that they don’t remember their size. We therefore decide we want to make a class called <code class="docutils literal notranslate"><span class="pre">Array</span></code> that stores both the data array and the size of it as a single object. We first define the object as</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">data</span></code> is a pointer to the first element of the underlying array, and <code class="docutils literal notranslate"><span class="pre">size</span></code> the number of elements.</p>
<p>Next we turn to making the constructor. When we make the constructor we want to take in the number of elements we want as an integer. The constructor should then allocate the memory of the array, set all the elements to zero, and point the <code class="docutils literal notranslate"><span class="pre">data</span></code> pointer to this array. You might try to do the following, but it won’t work:</p>
<p><strong>(NB: Doesn’t actually work)</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>While this looks reasonable, there is a big problem. Whenever a function finishes, everything created inside that function is automatically destroyed. As the array is created inside the constructor, it is destroyed too. Our pointer is set to point at this array, but if the thing pointed at is destroyed, the pointer won’t be much good.
If we try to run the following code</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>it produces the output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">31872064</span> <span class="mi">1</span> <span class="mi">31872064</span> <span class="mi">1</span> <span class="mi">30535429</span> <span class="mi">1</span> <span class="mi">31872064</span> <span class="mi">1</span>
</pre></div>
</div>
<p>and this output will change every time you run the program.</p>
<p>However, when using dynamic memory allocation, the data is not destroyed at the end of the function, and so will survive. To dynamically allocate an array, we do the following:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Now we see that we get the expected results.</p>
</div>
<div class="section" id="scope-and-lifetime">
<h3>Scope and lifetime<a class="headerlink" href="#scope-and-lifetime" title="Permalink to this headline">¶</a></h3>
<p>A scope is a the region or section where a variable can be accessed and you can think of the scope as the inner most curly braces (<code class="docutils literal notranslate"><span class="pre">{}</span></code>) that encapsulates the variable declaration. This could be in a function, but you can also simple create a scoped variable inside a function. The lifetime of an object is the portion of the program execution during which store is guaranteed to be reserved for it.</p>
<p>Consider the following code</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here we define an integer pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> and then inside a local scope (which we just create using curly braces) we create an integer variable <code class="docutils literal notranslate"><span class="pre">x</span></code> and points <code class="docutils literal notranslate"><span class="pre">p</span></code> at it. The problem with this code is that when we exit the scope and prints out the value that <code class="docutils literal notranslate"><span class="pre">p</span></code> points to, <code class="docutils literal notranslate"><span class="pre">x</span></code> does not exist anymore, and so <code class="docutils literal notranslate"><span class="pre">p</span></code> points at some address in memory that are now owned by the program anymore. Note that, you will probably still see <code class="docutils literal notranslate"><span class="pre">5</span></code> printed out on the console, but there is no guarantee that the value stored at this memory address will remain <code class="docutils literal notranslate"><span class="pre">5</span></code>. We call this <em>Undefined behavior</em> and this is the root of some of the most tricksiest bugs to debug.</p>
</div>
</div>
<div class="section" id="deallocating-memory-and-garbage-collection">
<h2>Deallocating Memory and Garbage Collection<a class="headerlink" href="#deallocating-memory-and-garbage-collection" title="Permalink to this headline">¶</a></h2>
<p>In Python, you are used to having built-in garbage collection. Garbage collection is a term for automatic processes that collects unused variables and destroys them for us, freeing the underlying memory. In Python, any variable that no longer has a name referencing it, is flagged for garbage collection and destroyed.</p>
<p>In C++, there is no garbage collection. Instead, data will be destroyed when it goes out of scope. However, as we just showed you, dynamic memory allocation survives even when it goes out of scope. This means dynamically allocated objects will continue to take memory until we ourselves destroy the objects.</p>
<p>If we <em>don’t</em> de-allocate memory we have created dynamically, it will continue to take space until our program finished. Often, this isn’t a problem, but in certain situations, it can actually lead to program-crashing bugs.</p>
<div class="section" id="memory-leaks">
<h3>Memory Leaks<a class="headerlink" href="#memory-leaks" title="Permalink to this headline">¶</a></h3>
<p>Earlier, we showed this snippet:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>
<span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>If we now do a new dynamic allocation:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">x</span></code> will point to a new object, but the old one is never freed. The other integer has no name, and we no longer have any pointer to it. We have reached a point where a piece of memory is locked down until the entire program terminates and we have no way of accessing or using that variable.
This is referred to as a memory leak.</p>
<p>A small memory leak is of no issue and not noticeable. However, if you get a large memory leak, the machine will run out of memory and the program and OS will grind to a halt, most likely requiring termination of the program or even a full reboot of the system.</p>
<p>Let us create a program that on purpose leaks a lot of memory:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">doomsday</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here we define an infinite loop. For each iteration we allocate a new integer in memory, but they are never deallocated. This means, for each iteration of the loop, our program will use a bit more memory (32 bits to be exact).</p>
<p>If we compile our <code class="docutils literal notranslate"><span class="pre">doomsday.cpp</span></code> code, you probably won’t get any warnings. But if you now run it, you definitely will get some problems. The program will ask for more and more memory from the system, and never give any back. The program never aborts itself or stops, so it is up to the system to recognize that this program is not acting right and terminate it. Wether or not that actually happens depends on your system. In the worst case, all memory will be hogged by the doomsday program, leaving non for the system. The only way to regain control in this scenario is now a hard reboot of the machine. Not ideal!</p>
<p>When I compile and run my doomsday.cpp program, the memory use of the computer skyrockets. When it maxes out the computer freezes for a few seconds and becomes unresponsive. Turns out my OS is successfully in terminating my program, freeing the memory.</p>
<div class="figure align-default" id="armageddon">
<a class="reference internal image-reference" href="../../../_images/armageddon.png"><img alt="armageddon" src="../../../_images/armageddon.png" style="width: 100px;" /></a>
</div>
<p>If you want to know how to debug such memory leaks, please consult the <a class="reference internal" href="cpptools.html"><span class="doc std std-doc">debugging section</span></a></p>
</div>
<div class="section" id="memory-leaks-in-practice">
<h3>Memory leaks in Practice<a class="headerlink" href="#memory-leaks-in-practice" title="Permalink to this headline">¶</a></h3>
<p>In practice, memory leaks are hard to detect. The leak doesn’t build up as fast as here, but does so over hours or days. When testing software, we often opt for small, efficient tests. And so often everything will seem fine, until we start a long simulation and we get an issue.</p>
<p>Memory leaks, and other similar bugs, sneak into a surprising amount of professional software, and is a major contributor to <a class="reference external" href="https://en.wikipedia.org/wiki/Software_aging"><em>software aging</em></a>, where things seem to become unresponsive or stop functioning when running over a longer time, but return to normal after a reboot.</p>
<p>The wikipedia article on memory leaks has a <a class="reference external" href="https://en.wikipedia.org/wiki/Memory_leak#An_example_of_memory_leak">good example</a> for how a seemingly “trivial” program for an elevator could contain a memory leak.</p>
</div>
<div class="section" id="freeing-memory">
<h3>Freeing memory<a class="headerlink" href="#freeing-memory" title="Permalink to this headline">¶</a></h3>
<p>So if dynamically allocated memory has to be freed, how do we do so? It is quite simple, we use the <code class="docutils literal notranslate"><span class="pre">delete</span></code> keyword:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>

<span class="k">delete</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">x</span></code> will free the thing pointed at by <code class="docutils literal notranslate"><span class="pre">x</span></code>, the pointer will still exist and be usable. If we are freeing an allocated array, we instead use <code class="docutils literal notranslate"><span class="pre">delete[]</span></code>:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span><span class="w"></span>

<span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="rule-of-thumb">
<h3>Rule of Thumb<a class="headerlink" href="#rule-of-thumb" title="Permalink to this headline">¶</a></h3>
<p>An easy rule of thumb to remember to avoid memory leak is that your code should have a <code class="docutils literal notranslate"><span class="pre">delete</span></code> statement for every <code class="docutils literal notranslate"><span class="pre">new</span></code> statement you use. Because <code class="docutils literal notranslate"><span class="pre">new</span></code> is the keyword used to dynamically allocate objects, we need to delete them.</p>
<p>Another technique that is recommended in the C++ community is known as <em>Resource Acquisition Is Initialization</em> or RAII which says that you should only acquire resources in the constructor and release them in the destructor.</p>
<div class="tip admonition">
<p class="admonition-title">Smart pointers</p>
<p>To prevent memory leaks, <a class="reference external" href="https://en.cppreference.com/book/intro/smart_pointers"><em>smart pointers</em></a> where introduced in C++11. This is the preferred what to deal with dynamic memory allocation in modern C++ projects, but is beyond the scope of this course.</p>
</div>
</div>
</div>
<div class="section" id="the-destructor">
<h2>The Destructor<a class="headerlink" href="#the-destructor" title="Permalink to this headline">¶</a></h2>
<p>Returning to our <code class="docutils literal notranslate"><span class="pre">Array</span></code> class example. We defined the following class:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">	</span><span class="n">Array</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">		</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>This class works well, and we can now use it inside other functions where we need arrays, however, at the end of those functions, our newly created <code class="docutils literal notranslate"><span class="pre">Array</span></code> object will automatically be destroyed. However, the dynamically allocated memory inside the object won’t be!</p>
<p>To ensure that the dynamic memory is deallocated with the object, we need to define a <em>destructor</em>, which is called automatically when an object goes out of scope and is destroyed. Where as the constructor is named the same as the class, the destructor is named the same with a tilde (~) in front:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">Array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>You could try this yourself with the simple test program:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">create_and_destroy_array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">Array</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="n">create_and_destroy_array</span><span class="p">();</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If you run this program without implementing the deallocator, the memory usage of the program will skyrocket. If you do implement the deallocator, then everything is fine, as every function call properly destroys the object and all the underlying data.</p>
</div>
<div class="section" id="stack-vs-heap">
<h2>Stack vs Heap<a class="headerlink" href="#stack-vs-heap" title="Permalink to this headline">¶</a></h2>
<p>In C++, and many other programming languages, we refer to two different forms of memory: the stack and the heap. Everything you create lives in one of these two memory spaces. Variables you create normally will live on the stack. Every function has its own stack space, and when the function finished, the stack is emptied and the variables destroyed. When you declare variables dynamically, you create them on the heap instead, where nothing is automatically deallocated.</p>
<p>We won’t talk much about stack and heap, but you might run across it in other sources, or if you ever learn more about C++ in more dedicated courses.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "finsberg/IN1910_H22",
            ref: "gh-pages",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./docs/lectures/cpp"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="oop_in_cpp.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Object-oriented Programming in C++</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="cpptools.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">C++ tips and tricks</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Jonas van den Brink, Henrik Finsberg, Kristian G. Hustad, and Joakim Sundnes<br/>
    
        &copy; Copyright 2022.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>